# 数字排序

## 问题
```
问题描述
　　给定n个整数，请统计出每个整数出现的次数，按出现次数从多到少的顺序输出。
输入格式
　　输入的第一行包含一个整数n，表示给定数字的个数。
　　第二行包含n个整数，相邻的整数之间用一个空格分隔，表示所给定的整数。
输出格式
　　输出多行，每行包含两个整数，分别表示一个给定的整数和它出现的次数。按出现次数递减的顺序输出。如果两个整数出现的次数一样多，则先输出值较小的，然后输出值较大的。
样例输入
12
5 2 3 3 1 3 4 2 5 2 3 5
样例输出
3 4
2 3
5 3
1 1
4 1
评测用例规模与约定
　　1 ≤ n ≤ 1000，给出的数都是不超过1000的非负整数。
```

## 思路  
```
主要要求：
输出多行，每行包含两个整数，分别表示一个给定的整数和它出现的次数。按出现次数递减的顺序输出。
如果两个整数出现的次数一样多，则先输出值较小的，然后输出值较大的。

思路还是排序，不过这次要求全部输出，就需要把数组先处理好，然后再整体输出
这时候就需要二维数组了，也就是a[n][2] ,其中a[n][0]存储数据，a[n][1]存储次数
我先把重复的数据整合到一起，也就是把相同的删掉，在第一个出现的数据上统计这个数出现的次数
整合完再按出现次数进行排序，次数相同的稍微处理一下
输出即可 
```

## 代码

```cpp
#include<iostream>  
using namespace std;  
  
int main(){  
    int n;  
    cin>>n;  
    int **a=new int* [n];   //创建数组   
    for(int i=0;i<n;i++)  
        a[i]=new int [2];  
  
    for(int i=0;i<n;i++){  //数组赋值   
        cin>>a[i][0];  
        a[i][1]=1;  
    }  
          
      
    for(int i=0;i<n-1;i++)     //计算出现次数并删除相同的数据  
        for(int j=i+1;j<n;j++)  
            if(a[i][0]==a[j][0]){  
                a[i][1]++;  
                for(int k=j;k<n-1;k++){  
                    a[k][0]=a[k+1][0];  
                    a[k][1]=a[k+1][1];  
                }  
                n--;   //n--是因为删掉一个数据   
                j--;   //j--是因为后边的数据都向前移，所以要重新比较，不然会漏掉   
            }  
      
    int temp;                        //按照出现次数多少排序   
    for(int i=0;i<n-1;i++)  
        for(int j=i+1;j<n;j++){  
            if(a[i][1]<a[j][1]){     //次数排序   
                temp=a[i][1];  
                a[i][1]=a[j][1];  
                a[j][1]=temp;  
                  
                temp=a[i][0];  
                a[i][0]=a[j][0];  
                a[j][0]=temp;  
            }  
            else if(a[i][1]==a[j][1])   //次数相同时数据大小排序   
                if(a[i][0]>a[j][0]){  
                    temp=a[i][1];  
                    a[i][1]=a[j][1];  
                    a[j][1]=temp;  
                  
                    temp=a[i][0];  
                    a[i][0]=a[j][0];  
                    a[j][0]=temp;  
                }  
        }  
          
    for(int i=0;i<n;i++){          //输出结果   
        cout<<a[i][0]<<" "<<a[i][1]<<endl;  
    }  
      
    delete[] a;       //动态数组需要手动回收空间   
    return 0;  
}  
```


---
2016/4/4  
